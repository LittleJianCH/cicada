import { Group } from "Group.cic"
import { Category } from "../category/index.cic"
import { equalSwap, equalMap, equalCompose } from "../equality/index.cic"

// Example of a big category.

class GroupHomomorphism {
  dom: Group
  cod: Group

  homo(dom.Element): cod.Element
  homoPreserveId: Equal(cod.Element, homo(dom.id), cod.id)
  homoPreserveMul(x: dom.Element, y: dom.Element): Equal(
    cod.Element,
    homo(dom.mul(x, y)),
    cod.mul(homo(x), homo(y)),
  )
}

function idGroupHomomorphism(G: Group): GroupHomomorphism(G, G) {
  return {
    dom: G,
    cod: G,
    homo: (x) => x,
    homoPreserveId: refl,
    homoPreserveMul: (x, y) => refl,
  }
}

function composeGroupHomomorphism(
  implicit G: Group,
  implicit H: Group,
  implicit K: Group,
  f: GroupHomomorphism(G, H),
  g: GroupHomomorphism(H, K),
): GroupHomomorphism(G, K) {
  return {
    dom: G,
    cod: K,

    homo: (x: G.Element) => g.homo(f.homo(x)),

    homoPreserveId: {
      let motive = Equal(
        K.Element,
        g.homo(f.homo(G.id)),
        K.id,
      )

      check f.homoPreserveId: Equal(
        H.Element,
        f.homo(G.id),
        H.id,
      )

      // check equalMap(f.homoPreserveId, ):

      check g.homoPreserveId: Equal(
        K.Element,
        g.homo(H.id),
        K.id,
      )

      return the(motive, refl)
    },

    // homoPreserveMul: (x, y) => equal K.Element {
    //   g.homo(f.homo(G.mul(x, y)))
    //   | equalMap(f.homoPreserveMul(x, y), g.homo)
    //   = g.homo(H.mul(f.homo(x), f.homo(y)))
    //   | g.homoPreserveMul(f.homo(x), f.homo(y))
    //   = K.mul(g.homo(f.homo(x)), g.homo(f.homo(y)))
    // },

    homoPreserveMul: (x, y) => {
      let motive = Equal(
        K.Element,
        g.homo(f.homo(G.mul(x, y))),
        K.mul(g.homo(f.homo(x)), g.homo(f.homo(y))),
      )

      check f.homoPreserveMul(x, y): Equal(
        H.Element,
        f.homo(G.mul(x, y)),
        H.mul(f.homo(x), f.homo(y)),
      )

      check equalMap(f.homoPreserveMul(x, y), g.homo): Equal(
        K.Element,
        g.homo(f.homo(G.mul(x, y))),
        g.homo(H.mul(f.homo(x), f.homo(y))),
      )

      check g.homoPreserveMul(f.homo(x), f.homo(y)): Equal(
        K.Element,
        g.homo(H.mul(f.homo(x), f.homo(y))),
        K.mul(g.homo(f.homo(x)), g.homo(f.homo(y))),
      )

      return equalCompose(
        equalMap(f.homoPreserveMul(x, y), g.homo),
        g.homoPreserveMul(f.homo(x), f.homo(y)),
      )
    }
  }
}

let groupCategory = new Category {
  Object: Group,
  Morphism: (G, H) => GroupHomomorphism(G, H),
  id: idGroupHomomorphism,
  // TODO Can not be just `composeGroupHomomorphism`
  compose: (implicit G, implicit H, implicit K, f, g) => composeGroupHomomorphism(implicit G, implicit H, implicit K, f, g),

  idLeft: (implicit G, implicit H, f) => {
    let G = f.dom
    let H = f.cod

    check G: Group
    check H: Group

    check f: GroupHomomorphism(G, H)

    let motive = Equal(
      GroupHomomorphism(G, H),
      composeGroupHomomorphism(implicit G, implicit G, implicit H, idGroupHomomorphism(G), f),
      // composeGroupHomomorphism(idGroupHomomorphism(G), f),
      f,
    )

    return the(motive, refl)
  },

  // // given G: Group, H: Group
  // idRight: (f: GroupHomomorphism(G, H)) => same(f)

  // // given G: Group, H: Group, K: Group, L: Group
  // composeAssociative: (f: GroupHomomorphism(G, H), g: GroupHomomorphism(H, K), h: GroupHomomorphism(K, L)) => refl
}
