import { Group } from "Group.cic"
import { Category } from "../category/index.cic"
import { equalSwap, equalMap, equalCompose } from "../equality/index.cic"
import {
  GroupHomomorphism,
  idGroupHomomorphism,
  composeGroupHomomorphism,
} from "GroupHomomorphism.cic"

let groupCategory = new Category {
  Object: Group,
  Morphism: (G, H) => GroupHomomorphism(G, H),
  id: idGroupHomomorphism,
  compose: composeGroupHomomorphism,

  // TODO Fail to readbeck
  // - left: [formatType] fail to readbackType: Equal
  // - left: [formatValue] fail to readback: TypedNeutral

  // idLeft: (f) => refl,

  idLeft: (implicit G, implicit H, f) => {
    let motive = Equal(
      GroupHomomorphism(G, H),
      composeGroupHomomorphism(idGroupHomomorphism(G), f),
      f,
    )

    // TODO Should we use `G.idLeft`?
    check G.idLeft: (x: G.Element) -> Equal(G.Element, G.mul(G.id, x), x)

    return the(motive, refl)
  },

  // TODO Wrong error:
  // - EvaluationError: [evaluate] undefined variable name: x

  // idLeft: (f) => {
  //   let G = f.dom
  //   let H = f.cod
  //   let motive = Equal(
  //     GroupHomomorphism(G, H),
  //     composeGroupHomomorphism(idGroupHomomorphism(G), f),
  //     f,
  //   )
  //   return the(motive, refl)
  // },

  // TODO Later

  // // given G: Group, H: Group
  // idRight: (f: GroupHomomorphism(G, H)) => same(f)

  // // given G: Group, H: Group, K: Group, L: Group
  // composeAssociative: (f: GroupHomomorphism(G, H), g: GroupHomomorphism(H, K), h: GroupHomomorphism(K, L)) => refl
}
